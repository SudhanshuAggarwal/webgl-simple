<!doctype html>
<html>
<head>
<title>Simple WebGL Application</title>
<!--
  WebGL works as a pipeline:
   - buffers of 'attributes' (from 1-4 values per) are passed to the graphics card
   - constant values ('uniforms') are also specified
   - the graphics card runs these attributes through a 'vertex shader' program to produce:
     * a location in the [-1,1]^3 cube
	 * some 'varying' values (1-4 values per)
   - the locations are connected into primitives (e.g. triangles), and the varying values are interpolated to sampling locations within each primitive
   - for each of these sampling locations ('fragments') a 'fragment shader' program is run to produce:
     * a color values
     * [optional] a depth value
   - finally, depending on the depth value, and resulting color is drawn into the framebuffer
--!>

<!--
  The code in helpers.js abstracts most of the pipeline setup, allowing you to focus on:
   - defining attributes
   - writing a vertex shader
   - writing a fragment shader
--!>

<!-- Attribute Generator --!>
<script>
function makeAttributes() {
	return {};
}
function makeUniforms() {
	return {};
}
</script>

<!-- Vertex Shader --!>
<script type="x-shader/x-glsl-vertex" id="vertexShader">
void main() {
	gl_Position = /* TODO */;
}
</script>

<!-- Fragment Shader --!>
<script type="x-shader/x-glsl-fragment" id="fragmentShader">
void main() {
	gl_FragColor = /* TODO */;
}
</script>

<script src="helpers.js" ></script>
</head>
<body onload="init()">
<canvas width="500" height="500"></canvas>
</body>
</html>
